<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@2.0.0 Forklift.glb --transform --shadows --root=factory/
-->

<script lang="ts">
	import { wasd } from '$lib/input';
	import {
		IntegrationParameters,
		JointData,
		PrismaticImpulseJoint,
		type RigidBody as RapierRigidBody,
		type Collider as RapierCollider
	} from '@dimforge/rapier3d-compat';
	import { T, forwardEventHandlers, useFrame } from '@threlte/core';
	import { useGltf } from '@threlte/extras';
	import { AutoColliders, Collider, CollisionGroups, RigidBody, useRapier } from '@threlte/rapier';
	import { Group, Quaternion, Vector3 } from 'three';
	import { DEG2RAD, degToRad } from 'three/src/math/MathUtils';

	export const ref = new Group();
	export let rigidBody: RapierRigidBody;
	let forksRigidBody: RapierRigidBody;

	let forkDominance: number | undefined;

	const gltf = useGltf('factory/Forklift-transformed.glb', { useDraco: true });

	const component = forwardEventHandlers();

	const { world } = useRapier();

	function createForkJoint(forklift: RapierRigidBody, forks: RapierRigidBody) {
		if (!forklift || !forks) return;
		let params = JointData.prismatic(
			{ x: 0.1, y: 0, z: 0 },
			{ x: 0, y: 1.7, z: 0 },
			{ x: 0, y: 1, z: 0 }
		);
		params.limitsEnabled = true;
		params.limits = [2.225, 3.5];
		world.createImpulseJoint(params, forklift, forks, true) as PrismaticImpulseJoint;
	}

	$: createForkJoint(rigidBody, forksRigidBody);

	useFrame((_, delta) => {
		if (!rigidBody) return;
		if ($wasd.w) {
			const { x, y, z, w } = rigidBody.rotation();
			const v = new Vector3(1, 0, 0);
			v.applyQuaternion(new Quaternion(x, y, z, w));
			rigidBody.setLinvel(v, true);
		}
		if ($wasd.a) {
			rigidBody.setAngvel({ x: 0, y: $wasd.s ? -1 : 1, z: 0 }, true);
		}
		if ($wasd.s) {
			const { x, y, z, w } = rigidBody.rotation();
			const v = new Vector3(-1, 0, 0);
			v.applyQuaternion(new Quaternion(x, y, z, w));
			rigidBody.setLinvel(v, true);
		}
		if ($wasd.d) {
			rigidBody.setAngvel({ x: 0, y: $wasd.s ? 1 : -1, z: 0 }, true);
		}
		if ($wasd.a && $wasd.d) {
			rigidBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
		}
		if ($wasd.space) {
			forkDominance = undefined;
			forksRigidBody.setLinvel({ x: 0, y: 0.5, z: 0 }, true);
		}
		if ($wasd.control) {
			forkDominance = undefined;
			forksRigidBody.setLinvel({ x: 0, y: -0.5, z: 0 }, true);
		}
		if (!$wasd.space && !$wasd.control) {
			forkDominance = 1;
			forksRigidBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
		}
		rigidBody.setRotation({ ...rigidBody.rotation(), x: 0, z: 0 }, true);
	});
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<RigidBody bind:rigidBody ccd>
			<T.Group position={[0, 1, 0]}>
				<!-- <slot /> -->

				<T.Group position={[0, 0.15, 0]}>
					<Collider shape="cuboid" args={[0.65, 0.65, 0.35]} />
				</T.Group>

				<T.Group position={[0.4, -0.2, 0]}>
					<Collider mass={1000} shape="cuboid" args={[0.25, 0.2, 0.25]} />
				</T.Group>

				<!-- Wheels -->
				<!-- <T.Group position={[0, 0, 0]}>
					<T.Group
						rotation={[degToRad(90), degToRad(90), wheelRotation]}
						position={[0.5, -0.55, 0.4]}
					>
						<Collider bind:collider={frontLeftWheel} shape="cylinder" args={[0, 0.2]} />
					</T.Group>
					<T.Group
						rotation={[degToRad(90), degToRad(90), wheelRotation]}
						position={[0.5, -0.55, -0.4]}
					>
						<Collider bind:collider={frontRightWheel} shape="cylinder" args={[0, 0.2]} />
					</T.Group>
					<T.Group
						rotation={[degToRad(90), degToRad(90), wheelRotation]}
						position={[-0.5, -0.55, 0.4]}
					>
						<Collider bind:collider={backLeftWheel} shape="cylinder" args={[0, 0.2]} />
					</T.Group>
					<T.Group
						rotation={[degToRad(90), degToRad(90), wheelRotation]}
						position={[-0.5, -0.55, -0.4]}
					>
						<Collider bind:collider={backRightWheel} shape="cylinder" args={[0, 0.2]} />
					</T.Group>
				</T.Group> -->

				<T.Group scale={0.25} position={[0, -0.5, 0]}>
					<T.Mesh
						castShadow
						receiveShadow
						geometry={gltf.nodes.Supports.geometry}
						material={gltf.materials.LP_Material}
					>
						<T.MeshStandardMaterial color="black" />
					</T.Mesh>
					<T.Mesh
						castShadow
						receiveShadow
						geometry={gltf.nodes.FrontWheels.geometry}
						material={gltf.materials.LP_Material}
					/>
					<T.Mesh
						castShadow
						receiveShadow
						geometry={gltf.nodes.BackLeftWheel.geometry}
						material={gltf.materials.LP_Material}
						position={[-1.99, 0.68, -1.28]}
					/>
					<T.Mesh
						castShadow
						receiveShadow
						geometry={gltf.nodes.BackRightWheel.geometry}
						material={gltf.materials.LP_Material}
						position={[-1.99, 0.68, 1.28]}
					/>
					<T.Mesh
						castShadow
						receiveShadow
						geometry={gltf.nodes.Lights.geometry}
						material={gltf.materials.LP_Material}
					>
						<T.MeshStandardMaterial color="#aa0000" opacity={0.8} transparent />
					</T.Mesh>
					<T.Mesh
						castShadow
						receiveShadow
						geometry={gltf.nodes.Roof.geometry}
						material={gltf.materials.LP_Material}
					>
						<T.MeshStandardMaterial color="#ffcc00" />
					</T.Mesh>
					<T.Mesh
						castShadow
						receiveShadow
						geometry={gltf.nodes.Axels.geometry}
						material={gltf.materials.LP_Material}
					/>
					<T.Mesh
						castShadowd
						receiveShadow
						geometry={gltf.nodes.Body.geometry}
						material={gltf.materials.LP_Material}
					>
						<T.MeshStandardMaterial color="#ffcc00" />
					</T.Mesh>
				</T.Group>

				<!-- Forks -->
				<RigidBody bind:rigidBody={forksRigidBody} gravityScale={0} dominance={forkDominance}>
					<T.Group position.x={-0.1}>
						<T.Group position={[1, -0.98, -0.22]}>
							<Collider friction={1} shape="cuboid" args={[0.25, 0.015, 0.04]} />
						</T.Group>
						<T.Group position={[1, -0.98, 0.22]}>
							<Collider friction={1} shape="cuboid" args={[0.25, 0.015, 0.04]} />
						</T.Group>
						<T.Group position={[0.75, -0.75, 0]}>
							<Collider friction={1} mass={2} shape="cuboid" args={[0.02, 0.25, 0.25]} />
						</T.Group>
						<T.Mesh castShadow scale={0.25} geometry={gltf.nodes.Forks.geometry}>
							<T.MeshPhongMaterial color="#555555" reflectivity={1} />
						</T.Mesh>
					</T.Group>
				</RigidBody>
			</T.Group>
		</RigidBody>
	{:catch error}
		<slot name="error" {error} />
	{/await}

	<slot {ref} />
</T>
